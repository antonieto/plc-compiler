import java_cup.runtime.*;
import lib.ExpressionSymbol;
import lib.Type;
import lib.SymTable;
import lib.FloatType;
import lib.CharType;
import lib.IntType;
import lib.ArrayType;
import java.util.ArrayList;

parser code {:
  public parser (java.io.Reader input) {
    super(new Yylex(input));
  }
:};

action code {:
    void print(String val) {
        PLXC.out.println(val);
    };

    void halt() {
        print("error;");
        print("halt;");
    };

    boolean checkExistance(String name) {
        if (!name.startsWith("$") && !SymTable.has(name)) {
            halt();
            return false;
        }
        return true;
    };
:}



// Keyword values
terminal IF, ELSE, WHILE, DO, FOR, PRINT;

// Parenthesis, separators
terminal LPAR, RPAR, LCURL, RCURL, LSQR, RSQR, SEMI, COMA;

// Operators
terminal ASIGN, PLUS, MINUS, UMINUS, TIMES, DIVIDE, EQ, NOTEQ, LT, LTEQ, GT, GTEQ, NOT, AND, OR;

// Basic symbols
terminal IDENT, INT, TYPE, FLOAT, CHAR;

// ======================================
// Now, nonterminals
nonterminal statement_list, statement, elseStatement, declStatement, forStatement;

// These production rules return registers
// condition: returns a register containing 0 or 1 (fale || true)
nonterminal String condition;
nonterminal ExpressionSymbol expression, forStepExpr;

// Declaration
nonterminal ArrayList<String> declaration;
// Util nonterminals
nonterminal String nt_newVar, nt_newLabel;

// Precedences
precedence left ELSE;
precedence left AND;
precedence left OR;
precedence left NOT;
precedence left PLUS, MINUS;
precedence left TIMES, DIVIDE;
precedence left UMINUS;
precedence left LPAR, RPAR;

statement_list ::= statement
    | statement_list statement;

// utils
nt_newVar ::= {:
    RESULT = PLXC.newVar();
:};
nt_newLabel ::= {:
    RESULT = PLXC.newLabel();
:};

statement ::= expression SEMI
    // Declaration statement
    | declStatement SEMI
    | IF
        nt_newLabel:ifLabel nt_newLabel:elseLabel nt_newLabel:endLabel
        LPAR  condition:cond {:
            print("if (" + cond + " == 1" + ") goto " + ifLabel + ";");
            print("if (" + cond + " == 0" + ") goto " + elseLabel + ";");
            print(ifLabel + ":");
        :} RPAR statement {:
            print("goto " + endLabel + ";");
            print(elseLabel + ":");
        :} elseStatement {:
            print("goto " + endLabel + ";");
            print(endLabel + ":");
        :}
    | WHILE nt_newLabel:cond_label nt_newLabel:end_label LPAR {:
        print(cond_label + ":");
    :} condition:c RPAR {:
        print("if (" + c + " == 0) goto " + end_label + ";");
        // Same as do-while, switch execution
    :} statement {:
        print("goto " + cond_label + ";");
        print(end_label + ":");
    :}
    | DO nt_newLabel:do_label {:
        print(do_label + ":");
    :} statement WHILE LPAR condition:c {:
        print("if (" + c + " == 1) goto " + do_label + ";");
    :} RPAR SEMI
    | forStatement
    | PRINT LPAR expression:v {:
        Type t = v.getType();
        print(t.printOperation(v));
        RESULT = v;
    :} RPAR SEMI
    | LCURL statement_list RCURL;

// Resolve IF ELSE
elseStatement ::= | ELSE statement;

forStatement ::= FOR LPAR forStepExpr SEMI
    nt_newLabel:cond_label nt_newLabel:do_label nt_newLabel:step_label nt_newLabel:end_label {:
        print(cond_label + ":");
    :} condition:c {:
        print("if (" + c + " == 1) goto " + do_label + ";");
        print("goto " + end_label + ";");
    :} SEMI {:
        print(step_label + ":");
    :} forStepExpr RPAR {:
        print("goto " + cond_label + ";");
        print(do_label + ":");
    :} statement {:
        print("goto " + step_label + ";");
        print(end_label + ":");
:};

forStepExpr ::= expression | ;


declStatement ::= TYPE:t declaration:ids {:
    for (String id: ids) {
        Type type = Type.getType(t.toString());
        SymTable.add(id, new ExpressionSymbol(id, type));
    }
:}
    // Simple array declaration first -> TYPE IDENT[expression] SEMI;
    | TYPE:t IDENT:id LSQR expression:len RSQR {:
        if (!len.isRegister()) {
            halt();
        }
        Type contentType = Type.getType(t.toString());
        Type arrayType = new ArrayType(contentType, 0);
        ExpressionSymbol sym = new ExpressionSymbol(id.toString(), arrayType);
        // Store size
        print(sym + "$SIZE = " + len + ";");
        SymTable.add(id.toString(), sym);
        RESULT = sym;
    :}
    ;
declaration ::= IDENT:id {:
        ArrayList<String> ls = new ArrayList<>();
        ls.add(id.toString());
        RESULT = ls;

    :}
    | IDENT:id COMA declaration:ids {:
        // Add id to beginning of list
        ids.add(0, id.toString());
        RESULT = ids;
    :}
    | IDENT:id ASIGN expression:e {:
        print(id + " = " + e + ";");
        ArrayList<String> ls = new ArrayList<>();
        ls.add(id.toString());
        RESULT = ls;
    :}
    | IDENT:id ASIGN expression:e COMA declaration:ids {:
        print(id + " = " + e + ";");
        ids.add(0, id.toString());
        RESULT = ids;
    :}
    ;

// Expression definition
expression ::= expression:e1 PLUS expression:e2 {:
        if (!e1.isCompatibleWith(e2)) {
            halt();
        }
        Type t1 = e1.getType();
        Type t2 = e2.getType();
        Type floatType = FloatType.getInstance();
        // Prioritize float
        Type t = t1 == floatType || t2 == floatType ? floatType : e1.getType();
        ExpressionSymbol dest = new ExpressionSymbol(PLXC.newVar(), t);
        String line = t.addOperation(dest, e1, e2);
        print(line);
        RESULT = dest;
    :}
    | expression:e1 MINUS expression:e2 {:
        if (!e1.isCompatibleWith(e2)) {
            halt();
        }
        Type t = e1.getType();
        ExpressionSymbol dest = new ExpressionSymbol(PLXC.newVar(), t);
        String line = t.subsOperation(dest, e1, e2);
        print(line);
        RESULT = dest;
    :}
    | expression:e1 TIMES expression:e2 {:
        if (!e1.isCompatibleWith(e2)) {
            halt();
        }
        Type t = e1.getType();
        ExpressionSymbol dest = new ExpressionSymbol(PLXC.newVar(), t);
        String line = t.multOperation(dest, e1, e2);
        print(line);
        RESULT = dest;
    :}
    | expression:e1 DIVIDE expression:e2 {:
        if (!e1.isCompatibleWith(e2)) {
            halt();
        }
        Type t = e1.getType();
        ExpressionSymbol dest = new ExpressionSymbol(PLXC.newVar(), t);
        String line = e1.getType().divideOperation(dest, e1, e2);
        print(line);
        RESULT = dest;
    :}
    | MINUS expression:e1 {:
        ExpressionSymbol tmp = new ExpressionSymbol(PLXC.newVar(), e1.getType());
        ExpressionSymbol dest = new ExpressionSymbol(PLXC.newVar(), e1.getType());
        print(tmp + " = 0;");
        Type t = e1.getType();
        String line = t.subsOperation(dest, tmp, e1);
        print(line);
        RESULT = dest;
    :} %prec UMINUS// Unary minus (add precedence)
    | LPAR TYPE:t RPAR expression:e1 {:
        Type type = Type.getType(t.toString());
        ExpressionSymbol temp = new ExpressionSymbol(PLXC.newVar(), type);
        String line = type.castOperation(temp, e1);
        print(line);
        RESULT = temp;
    :}
    | LPAR expression:e {: RESULT = e; :} RPAR
    | IDENT:id ASIGN expression:e {:
        if (!SymTable.has(id.toString())) {
            halt();
            RESULT = e;
        }
        ExpressionSymbol sym = SymTable.get(id.toString());
        Type t = sym.getType();
        if (!sym.isCompatibleWith(e)) {
            halt();
            RESULT = e;
        } else {
            print(t.assignOperation(sym, e));
            RESULT = e;
        }

     :}
    // Indexed assignment
    | IDENT:id LSQR expression:index RSQR ASIGN expression:e {:
         if (!SymTable.has(id.toString())) {
             halt();
             RESULT = e;
         }
         ExpressionSymbol sym = SymTable.get(id.toString());
         if (!(sym.getType() instanceof ArrayType)) {
            halt();
         }
         ArrayType arrayType = (ArrayType) sym.getType();
         boolean exprMatchesArrayType = arrayType.getContentType().isCompatibleWith(e.getType());
         boolean isIndexInt = index.getType() == IntType.getInstance();
         // If operand doesn't match array type
         if (!exprMatchesArrayType || !isIndexInt) {
            halt();
         }

         String haltLabel = PLXC.newLabel();
         String continueLabel = PLXC.newLabel();
         print("if (" + index + " < 0) goto " + haltLabel + ";");
         print("if (" + sym + "$SIZE < " + index + ") goto " + haltLabel + ";");
         print("if (" + sym + "$SIZE == " + index + ") goto " + haltLabel + ";");
         print("goto " + continueLabel + ";");
         print(haltLabel + ":");
         halt();
         print(continueLabel + ":");
         // Assignment
         print("# index is: " + index);
         print(id + "[" + index + "] = " + e + ";");
         RESULT = e;
    :}
    | IDENT:id {:
        if(!SymTable.has(id.toString())) {
            halt();
        }
        RESULT = SymTable.get(id.toString());
    :}
    | INT:val {:
        String var = PLXC.newVar();
        print(var + " = " + val + ";");
        RESULT = new ExpressionSymbol(var, IntType.getInstance());
    :}
    | FLOAT:val {:
        String var = PLXC.newVar();
        print(var + " = " + val + ";");
        RESULT = new ExpressionSymbol(var, FloatType.getInstance());
    :}
    | CHAR:val {:
        ExpressionSymbol sym = new ExpressionSymbol(PLXC.newVar(), CharType.getInstance());
        print(sym + " = " + CharType.strToASCII(val.toString()) + "; # assigning");
        RESULT = sym;
    :}
    // Array indexing
    | IDENT:id LSQR expression:e RSQR {:
        // Index array at id
        if (!SymTable.has(id.toString())) {
            halt();
        }
        ExpressionSymbol sym = SymTable.get(id.toString());
        Type t = sym.getType();
        if (!(t instanceof ArrayType) || e.getType() != IntType.getInstance()) {
            halt();
        }

        // Range check
        String haltLabel = PLXC.newLabel();
        String continueLabel = PLXC.newLabel();
        print("if (" + e + " < 0) goto " + haltLabel + ";");
        print("if (" + sym + "$SIZE < " + e + ") goto " + haltLabel + ";");
        print("if (" + sym + "$SIZE == " + e + ") goto " + haltLabel + ";");
        print("goto " + continueLabel + ";");
        print(haltLabel + ":");
        halt();
        print(continueLabel + ":");

        Type contentType = ((ArrayType) t).getContentType();
        ExpressionSymbol tmp = new ExpressionSymbol(PLXC.newVar(), contentType);
        print(tmp + " = " + id.toString() + "[" + e + "];");
        RESULT = tmp;
    :}
    ;
condition ::= expression:e1 EQ expression:e2 {:
        String var = PLXC.newVar();
        String trueL = PLXC.newLabel();
        String endL = PLXC.newLabel();
        print("if (" + e1 + " == " + e2 + ") goto " + trueL + ";");
        // False block first
        print(var + " = 0;");
        print("goto " + endL + ";");
        print(trueL + ":");
        print(var + " = 1;");
        print(endL + ":");
        RESULT = var;
    :}
    | expression:e1 NOTEQ expression:e2 {:
        String var = PLXC.newVar();
        String trueL = PLXC.newLabel();
        String endL = PLXC.newLabel();
        print("if (" + e1 + " != " + e2 + ") goto " + trueL + ";");
        // False block first
        print(var + " = 0;");
        print("goto " + endL + ";");
        print(trueL + ":");
        print(var + " = 1;");
        print(endL + ":");
        RESULT = var;
    :}
    | expression:e1 LT expression:e2 {:
        String var = PLXC.newVar();
        String trueL = PLXC.newLabel();
        String endL = PLXC.newLabel();
        print("if (" + e1 + " < " + e2 + ") goto " + trueL + ";");
        // False block first
        print(var + " = 0;");
        print("goto " + endL + ";");
        print(trueL + ":");
        print(var + " = 1;");
        print(endL + ":");
        RESULT = var;
    :}
    | expression:e1 LTEQ expression:e2 {:
        String var = PLXC.newVar();
        String tl = PLXC.newLabel();
        String el = PLXC.newLabel();

        print("if (" + e1 + " < " + e2 + ") goto " + tl + ";");
        print("if (" + e1 + " == " + e2 + ") goto " + tl + ";");
        // False part
        print(var + " = 0;");
        print("goto " + el + ";");
        // True part
        print(tl + ":");
        print(var + " = 1;");
        // End
        print(el + ":");
        RESULT = var;
    :}
    | expression:e1 GT expression:e2 {:
        String var = PLXC.newVar();
        String fl = PLXC.newLabel();
        String el = PLXC.newLabel();

        print("if (" + e1 + " < " + e2 + ") goto " + fl + ";");
        print("if (" + e1 + " == " + e2 + ") goto " + fl + ";");
        // True part
        print(var + " = 1;");
        print("goto " + el + ";");
        // False part
        print(fl + ":");
        print(var + " = 0;");
        // End
        print(el + ":");
        RESULT = var;
    :}
    | expression:e1 GTEQ expression:e2 {:
         String var = PLXC.newVar();
         String trueL = PLXC.newLabel();
         String endL = PLXC.newLabel();
         print("if (" + e1 + " < " + e2 + ") goto " + trueL + ";");
         // False block
         print(var + " = 1;");
         print("goto " + endL + ";");
         // True block
         print(trueL + ":");
         print(var + " = 0;");
         // End
         print(endL + ":");
         RESULT = var;
    :}
    | NOT condition:c {:
        String trueL = PLXC.newLabel();
        String endL = PLXC.newLabel();
        print("if (" + c + " == 1) goto " + trueL + ";");
        print(c + " = 1;");
        print("goto " + endL + ";");
        print(trueL + ":");
        print(c + " = 0;");
        print(endL + ":");
        RESULT = c;
    :}
    |  condition:c1 AND nt_newLabel:fl {:
        // Short circuit
        print("if (" + c1 + " == 0) goto " + fl + ";");
    :} condition:c2 {:
        String var = PLXC.newVar();
        String trueLabel = PLXC.newLabel();
        String endLabel = PLXC.newLabel();

        print("if (" + c2 + " == 0) goto " + fl + ";");
        print("goto " + trueLabel + ";");

        // Labels and actions
        print(trueLabel + ":");
        print(var + " = 1;");
        print("goto " + endLabel + ";");
        print(fl + ":");
        print(var + " = 0;");
        print("goto " + endLabel + ";");

        print(endLabel + ":");
        RESULT = var;
    :}
    | condition:c1 OR nt_newLabel:tl {:
        // Short circuit
        print("if (" + c1 + " == 1) goto " + tl + ";");
    :} condition:c2 {:
        String var = PLXC.newVar();
        String falseLabel = PLXC.newLabel();
        String endLabel = PLXC.newLabel();

        print("if (" + c2 + " == 1) goto " + tl + ";");
        print("goto " + falseLabel + ";");

        // Labels and actions
        print(tl + ":");
        print(var + " = 1;");
        print("goto " + endLabel + ";");

        print(falseLabel + ":");
        print(var + " = 0;");

        print(endLabel + ":");
        RESULT = var;
    :}
    | LPAR condition:c1 {: RESULT = c1; :} RPAR;
